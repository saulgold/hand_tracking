#include "mainwindow.h"
#include "ui_mainwindow.h"

#include<QFileDialog>
#include<QtCore>


cv::Mat MOGmask;
int min_3,max_1,max_2,max_3;
int min_1 =1;
int min_2 =1;
cv::Mat prev_frame,frame_gray;
cv::Mat m_frame,m_frame_col;
int adaptive_mask;
int dilate_size =3;
int erode_size =3;
int threshold_val = 0;
bool mean_button = false;
cv::BackgroundSubtractorMOG2 bg;
cv::Mat fgMaskMOG; //fg mask generated by MOG method
cv::Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
cv::Mat fgMaskGMG; //fg mask fg mask generated by MOG2 method
cv::Ptr<cv::BackgroundSubtractor> pMOG = cv::Algorithm::create<cv::BackgroundSubtractorMOG>("BackgroundSubtractor.MOG"); //MOG Background subtractor
cv::Ptr<cv::BackgroundSubtractor> pMOG2 = cv::Algorithm::create<cv::BackgroundSubtractorMOG2>("BackgroundSubtractor.MOG2"); //MOG2 Background subtractor
cv::Ptr<cv::BackgroundSubtractor> pGMG = cv::Algorithm::create<cv::BackgroundSubtractorGMG>("BackgroundSubtractor.GMG"); //MOG2 Background subtractor
//cv::Ptr<cv::SimpleBlobDetector> blobDetector = cv::Algorithm::create<cv::SimpleBlobDetector>("SimpleBlobDetector");
bool background_frame_button = false;




MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{

    if(!m_cap.open(0)){
        qDebug()<<"webcam no open";
    }

    blurSize=1;
    ui->setupUi(this);
    timer = new QTimer(this);

    connect(timer,SIGNAL(timeout()),this,SLOT(updateGUI()));

    timer->start();
    thresholdSliderValue = 1;
    thresholdSliderValue1=1;
    pMOG = new cv::BackgroundSubtractorMOG(); //MOG approach
    pMOG2 = new cv::BackgroundSubtractorMOG2(); //MOG2 approach
    pMOG2->set("detectShadows",0);
    pMOG2->set("nmixtures",3);
     pMOG2->set("history",20);


    // pMOG = cv::createBackgroundSubtractorMOG2();
}

MainWindow::~MainWindow()
{
    delete ui;
}



void MainWindow::updateGUI(){
//cv::SimpleBlobDetector blob_detector(params);
  cv::Mat frame_hsv_threshold,frame_hsv,frame_hsv_contours,frame_threshold;

//  min_frame.setTo(cv::Scalar(0,133,77));
//  max_frame.setTo(cv::Scalar(255,173,127));


  QImage qframe;
//  cv::Size blurMask = cv::Size(6,6);

   m_cap>>m_frame_col;
   cv::copyMakeBorder(m_frame_col,m_frame_col,10,10,10,10,cv::BORDER_CONSTANT ,cv::Scalar(255,255,255));

   cv::flip(m_frame_col,m_frame_col,1);
  cv::cvtColor(m_frame_col,m_frame,CV_BGR2GRAY);
//   cv::cvtColor(m_frame_col,frame_gray,CV_BGR2GRAY);
   cv::cvtColor(m_frame_col,frame_hsv,CV_BGR2YCrCb);
   //cv::cvtColor(m_frame_col,ycc_frame,CV_BGR2HSV);

  // cv::bitwise_not(m_frame,m_frame);

 if(roiMean1!= cv::Scalar(0,0,0)){
      cv::inRange(frame_hsv,roiMean1-roiSD,roiMean1+roiSD,frame_hsv_threshold);
//      cv::inRange(ycc_frame,roiMean2-cv::Scalar(1,1,1),roiMean2+cv::Scalar(1,1,1),ycc_frame2);uter
//      cv::inRange(ycc_frame,roiMean3-cv::Scalar(1,1,1),roiMean3+cv::Scalar(1,1,1),ycc_frame3);
//      cv::inRange(ycc_frame,roiMean4-cv::Scalar(1,1,1),roiMean4+cv::Scalar(1,1,1),ycc_frame4);
//      //ycc_frame =  ycc_frame1+ ycc_frame2+ ycc_frame3+ ycc_frame4;
//      cv::medianBlur(ycc_frame,ycc_blur_frame,5);

  }

//   cv::blur(m_frame,m_frame,blurMask);
  // cv::GaussianBlur(frame_gray,frame_gray_blur,cv::Size(7,7),3,3);
//   adaptive_mask = (2*thresholdSliderValue) +1;
      //cv::GaussianBlur(m_frame,m_frame,cv::Size(7,7),3,3);
      cv::threshold(m_frame,m_frame,thresholdSliderValue,255,1);
  //cv::adaptiveThreshold(m_frame,m_frame,255,CV_ADAPTIVE_THRESH_MEAN_C,CV_THRESH_BINARY,13,1);
//  cv::bilateralFilter(m_frame,frame_gray_blur,9,32,260);
//  cv::adaptiveThreshold(frame_gray_blur,frame_threshold,255,CV_ADAPTIVE_THRESH_MEAN_C,CV_THRESH_BINARY,5,1);


//  cv::Canny(m_frame,m_frame,thresholdSliderValue,thresholdSliderValue1);

//  cv::bitwise_not(m_frame,m_frame);


    //m_frame = frame_hsv_threshold;
  if(!frame_hsv_threshold.empty()){
      cv::Mat dilate_mask = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(8,8));
      cv::Mat erode_mask = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(2,2));
       cv::dilate(frame_hsv_threshold,frame_hsv_threshold,dilate_mask);
       cv::erode(frame_hsv_threshold,frame_hsv_threshold,erode_mask);
      frame_hsv_contours = frame_hsv_threshold;
    cv::findContours(frame_hsv_contours,contours, hierarchy,CV_RETR_TREE,CV_CHAIN_APPROX_NONE,cv::Point(0,0));


  double largest_area = 0;
  int largest_contour_index= 0;

  for(int i=0; i < contours.size();i++){
      double area = cv::contourArea(contours[i],false);

      if (area>largest_area){
          largest_area=area;
          largest_contour_index =i;
      }

  }
     cv::drawContours(m_frame_col,contours,largest_contour_index,cv::Scalar(255,0,50),2,8,hierarchy, 0, cv::Point());

//  for( int i = 0; i< contours.size(); i++ ){
//    if (cv::contourArea(contours[i],false)>50000){
//    cv::drawContours(m_frame_col,contours,i,cv::Scalar(255,0,50),2,8,hierarchy, 0, cv::Point());
//    }
//  }
  }
    //cv::threshold(m_frame,m_frame,threshold_val,255,1);

  // cv::fastNlMeansDenoising(m_frame,m_frame,3,7,21);

//    pMOG->operator()(frame_gray, fgMaskMOG,0.5);
//    pMOG2->operator()(frame_gray, fgMaskMOG2,-0.5);
//    pGMG->operator()(frame_gray, fgMaskGMG,0.1);

    if(background_frame_button){
        m_cap>>background_frame;
        cv::flip(background_frame,background_frame,1);
        cv::cvtColor(background_frame,background_frame,CV_BGR2HSV);

//        cv::GaussianBlur(background_frame,background_frame,cv::Size(7,7),3,3);
//          cv::adaptiveThreshold(m_frame,m_frame,255,CV_ADAPTIVE_THRESH_MEAN_C,CV_THRESH_BINARY,13,1);
        background_frame_button=false;
    }//else(background_frame = cv::Scalar::all(0));

    if(m_frame_col.cols==background_frame.cols && m_frame_col.rows==background_frame.rows ){
        //m_frame = m_frame - background_frame;

       cv::subtract(frame_hsv,background_frame,frame_hsv);
    //cv::bitwise_not(m_frame,m_frame);
       // cv::inRange(frame2,cv::Scalar(threshold_val-30),cv::Scalar(threshold_val+30),inrange_frame);


//        if(m_frame.channels()==1){
//       uchar pixel;
//       uchar white =255;
//        for(int i=0; i<m_frame.rows;i++){
//            for(int j=0; j<m_frame.cols;j++){
//                pixel = m_frame.at<uchar>(i,j)- background_frame.at<uchar>(i,j);
//                if(pixel<0 ){
//                    m_frame.at<uchar>(i,j)=white;
//                }else(m_frame.at<uchar>(i,j)=pixel);
//               // qDebug()<<i<<", "<<j;
//            }
//        }
//    }else(qDebug()<<"subtraction only works on binary images");
    }

 //

// // cv::threshold(frame,frame,thresholdSliderValue,255,CV_THRESH_BINARY_INV);
 cv::rectangle(frame_hsv,cv::Rect(100,100,100,100),cv::Scalar(255,0,100));

//  cv::rectangle(frame_gray,cv::Rect(130,130,40,40),cv::Scalar(255,0,100));
//   cv::rectangle(ycc_frame,cv::Rect(190,130,40,40),cv::Scalar(0,0,100));
//  cv::rectangle(ycc_frame,cv::Rect(130,190,40,40),cv::Scalar(90,0,100));
//  cv::rectangle(ycc_frame,cv::Rect(190,190,40,40),cv::Scalar(0,255,100));

    if(mean_button){
        cv::Mat roi1 = frame_hsv(cv::Rect(100,100,100,100));
//        cv::Mat roi2 = ycc_frame(cv::Rect(190,130,40,40));
//        cv::Mat roi3 = ycc_frame(cv::Rect(130,190,40,40));
//        cv::Mat roi4 = ycc_frame(cv::Rect(190,190,40,40));

        cv::meanStdDev(roi1,roiMean1,roiSD);
//        n2 = cv::mean(roi2);
//        roiMean3 = cv::mean(roi3);
//        roiMean4 = cv::mean(roi4);
//        int sum=0;
//        for(int i =100; i<200;i++){
//           for(int j =100; j<200;j++){
//               sum += frame_gray.at<uchar>(i,j);
//           }
//        }
       mean_button=false;

    }
cv::imshow("sdaf",frame_hsv);
  ui->meanIntensityLabel->setNum(threshold_val);
  qframe = convertOpenCVMatToQtQImage(m_frame_col);
  QPixmap pix = QPixmap::fromImage(qframe);
  ui->videoScreen->setPixmap(pix);
}


QImage MainWindow::convertOpenCVMatToQtQImage(cv::Mat mat) {
    if(mat.channels() == 1) {                   // if grayscale image
        return QImage((uchar*)mat.data, mat.cols, mat.rows, mat.step, QImage::Format_Indexed8);     // declare and return a QImage
    } else if(mat.channels() == 3) {            // if 3 channel color image
        cv::cvtColor(mat, mat, CV_BGR2RGB);     // invert BGR to RGB
        return QImage((uchar*)mat.data, mat.cols, mat.rows, mat.step, QImage::Format_RGB888);       // declare and return a QImage
         qDebug() << "in convertOpenCVMatToQtQImage, image was not 1 channel or 3 channel, should never get here";
    }
    return QImage();        // return a blank QImage if the above did not work
}

void MainWindow::on_thresholdSlider_valueChanged(int value)
{
    thresholdSliderValue = value;
}

void MainWindow::on_blurSlider_valueChanged(int value)
{
    thresholdSliderValue1 = value;
}

void MainWindow::on_minSlider1_valueChanged(int value)
{
    min_1 = value;
}

void MainWindow::on_minSlider2_valueChanged(int value)
{
    min_2 = value;
}

void MainWindow::on_minSlider3_valueChanged(int value)
{
    min_3 = value;
}

void MainWindow::on_maxSlider1_valueChanged(int value)
{
    max_1 = value;
}

void MainWindow::on_maxSlider2_valueChanged(int value)
{
    max_2 = value;
}

void MainWindow::on_maxSlider3_valueChanged(int value)
{
    max_3 = value;
}

void MainWindow::on_backgroudCalibration_clicked()
{


}



void MainWindow::on_getThreshold_clicked()
{
    mean_button = true;
}

void MainWindow::on_backgroudCalibration_released()
{

      background_frame_button = true;
}
